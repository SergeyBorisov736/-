1.Сортировка выбором (Selection Sort) —на каждом шаге алгоритма находят минимальный элемент среди последних и меняют его местами с текущим элементом в массиве. C++ 
Объяснение работы алгоритма: 

Алгоритм делит массив на две части: отсортированную (в начале) и неотсортированную (в конце) 

На каждой итерации находится минимальный элемент в неотсортированной части массива 

Найденный минимальный элемент меняется местами с первым элементом неотсортированной части 

После каждой итерации отсортированная часть увеличивается на один элемент 

Процесс повторяется до тех пор, пока весь массив не будет отсортирован 

int - тип данных для целых чисел, используется для объявления массива и переменных 

for - цикл с предопределенным количеством итераций, состоит из инициализации, условия и инкремента 

if - условный оператор, выполняет код только если условие истинно 

swap - стандартная функция, меняющая местами значения двух переменных 

cout - объект для вывода данных в консоль, оператор << направляет данные в поток вывода 



Временная сложность: O(n²) во всех случаях (лучшем, среднем и худшем), где n - количество элементов в массиве. Это связано с тем, что алгоритм всегда выполняет двойной цикл, независимо от исходного порядка элементов. 

2.Сортировка обменом (пузырьком) —  алгоритм проходит по списку несколько раз, сравнивая соседние элементы и меняя их местами, если они находятся в неправильном порядке. Процесс повторяется до тех пор, пока список полностью не отсортируется. Python
Объяснение работы алгоритма: 

Алгоритм проходит по массиву многократно, сравнивая соседние элементы 

Если два соседних элемента находятся в неправильном порядке, они меняются местами 

На каждой итерации самый большой элемент "всплывает" в конец массива 

Процесс повторяется до тех пор, пока массив не будет полностью отсортирован 

list - встроенный тип данных Python для хранения упорядоченных коллекций 

for - цикл перебора элементов последовательности, автоматически итерирует по range() 

range() - функция генерации последовательности чисел с заданными параметрами 

if - условный оператор, проверяющий булево выражение 

 


Временная сложность: O(n²) в худшем и среднем случаях, O(n) в лучшем случае (когда массив уже отсортирован). 

3.Сортировка вставками — алгоритм строит отсортированную часть списка,постепенно вставляя каждый элемент на своё место. Он начинает с первого элемента и перемещается вправо, сравнивая каждый элемент с предыдущими элементами и вставляя его на правильное место. C++ 
Объяснение работы алгоритма: 

Алгоритм делит массив на отсортированную и неотсортированную части 

Каждый новый элемент вставляется в правильную позицию в отсортированной части 

Элементы большие чем вставляемый сдвигаются вправо 

Процесс повторяется пока все элементы не будут вставлены в отсортированную часть 

nt[] - объявление массива фиксированного размера с явной инициализацией 

for - цикл с объявлением итерационной переменной, выполняющий n-1 итераций 

while - цикл с предварительной проверкой условия, выполняется пока условие истинно 

&& - логический оператор И, оба условия должны быть истинны 

j-- - оператор декремента, уменьшает значение переменной на 1 



Временная сложность: O(n²) в худшем и среднем случаях, O(n) в лучшем случае (когда массив уже отсортирован).

4.Сортировка слиянием —алгоритм состоит в разделении массива пополам,сортировке половин и их слиянии C++ 
Объяснение работы алгоритма: 

Алгоритм использует стратегию "разделяй и властвуй" 

Массив рекурсивно делится пополам до тех пор, пока не останутся подмассивы из одного элемента 

Затем подмассивы сливаются обратно в отсортированном порядке 

Процесс слияния сравнивает элементы из двух подмассивов и размещает их в правильном порядке 

void - спецификатор типа для функций, которые не возвращают значения 

Рекурсия - вызов функции самой себя с измененными параметрами 

if(l < r) - условие остановки рекурсии (массив из одного элемента) 

m = l+(r-l)/2 - безопасное вычисление середины (избегает переполнения) 

k++ - постинкремент: сначала используется значение, затем увеличивается 

? : - тернарный условный оператор (условие ? значение1 : значение2) 



Временная сложность: O(n log n) во всех случаях (лучшем, среднем и худшем). 

5.Сортировка Шелла — является модификацией сортировки вставками,сортирует между собой элементы, стоящие на местах, кратных определённому шагу. Python 
Объяснение работы алгоритма: 

Алгоритм является улучшенной версией сортировки вставками 

Сортировка выполняется с определенным шагом (gap), который постепенно уменьшается 

На каждом шаге сортируются элементы, отстоящие друг от друга на расстоянии gap 

Когда gap становится равным 1, алгоритм работает как обычная сортировка вставками 

len() - встроенная функция, возвращает количество элементов в последовательности 

// - оператор целочисленного деления (отбрасывает дробную часть) 

while - цикл с условием, выполняющийся до тех пор пока условие истинно 

for...in range() - цикл перебора числовой последовательности 


Временная сложность: O(n²) в худшем случае, O(n log n) в лучшем случае. 

6.Быстрая сортировка —один из самых известных и широко используемых алгоритмов сортировки. Алгоритм состоит в выборе опорного элемента, разделении массива на две части относительно опорного (одна — все элементы,меньшие опорного элемента, вторая — большие), и в сортировке полученных частей рекурсивным вызовом себя от них.Python 
Объяснение работы алгоритма: 

Алгоритм использует стратегию "разделяй и властвуй" 

Выбирается опорный элемент (pivot) 

Массив разделяется на три части: элементы меньше pivot, равные pivot и больше pivot 

Рекурсивно применяется к левой и правой частям 

Объединяет результаты в отсортированный массив 

def - ключевое слово для объявления пользовательской функции 

if len(arr) <= 1 - условие базового случая рекурсии 

return - оператор возврата значения из функции 



Временная сложность: O(n log n) в среднем случае, O(n²) в худшем случае. 
7.Пирамидальная сортировка —алгоритм строит кучу из исходного списка, затем постепенно извлекает наибольший элемент из кучи и помещает его в конец списка C++ 
Объяснение работы алгоритма: 

Алгоритм строит из массива двоичную кучу (max-heap) 

Корень кучи (наибольший элемент) перемещается в конец массива 

Куча перестраивается для оставшихся элементов 

Процесс повторяется пока куча не опустеет 

heapify - функция поддержки свойства кучи (родитель >= потомков) 

2*i+1, 2*i+2 - формулы для вычисления индексов левого и правого потомков 

Рекурсия в heapify - гарантирует сохранение свойства кучи во всем поддереве 

Временная сложность: O(n log n) во всех случаях. 

8.Последовательный поиск —простейший вид поиска заданного элемента на некотором множестве. Осуществляется путём последовательного сравнения очередного рассматриваемого значения с искомым до тех пор, пока эти значения не совпадут. Этот метод является наименее эффективным, так как его временная сложность составляет O(n), n — количество элементов в списке. Однако он прост в реализации и может быть полезен для небольших списков . 
Объяснение работы алгоритма: 

Алгоритм последовательно проверяет каждый элемент массива 

Сравнивает текущий элемент с искомым значением 

Если элемент найден, возвращает его индекс 

Если элемент не найден после проверки всего массива, возвращает -1 

for...else - конструкция где else выполняется если цикл не был прерван break 

break - оператор немедленного выхода из цикла 



Временная сложность: O(n) в худшем случае, O(1) в лучшем случае.
9.Бинарный поиск — это поиск заданного элемента на упорядоченном множестве, осуществляемый путём неоднократного деления этого множества на две части таким образом, что искомый элемент попадает в одну из этих частей. Поиск заканчивается при совпадении искомого элемента с элементом, который является границей между частями множества или при отсутствии искомого элемента. Преимуществом бинарного поиска является более низкая трудоёмкость по сравнению с последовательным поиском. Недостаток заключается в том, что он применим только на отсортированных множествах C++ 
Объяснение работы алгоритма: 

Алгоритм работает только с отсортированными массивами 

На каждом шаге область поиска уменьшается вдвое 

Сравнивает средний элемент с искомым значением 

В зависимости от результата продолжает поиск в левой или правой половине 

while(l <= r) - условие продолжения поиска (левая граница <= правой) 

mid = l + (r-l)/2 - безопасное вычисление середины (избегает переполнения) 

arr[mid] == target - проверка найден ли элемент в средней позиции 



Временная сложность: O(log n) во всех случаях.

10.Интерполирующий поиск — это алгоритм поиска для отсортированных наборов данных,таких как массивы или списки. Он предсказывает позицию нужного элемента на основе разницы значений. Эффективен, если элементы распределены достаточно равномерно C++ 
Объяснение работы алгоритма: 

Улучшенная версия бинарного поиска 

Использует интерполяционную формулу для предсказания позиции искомого элемента 

Особенно эффективен при равномерном распределении данных 

На каждом шаге вычисляет вероятную позицию элемента на основе его значения 

target >= arr[l] && target <= arr[r] - проверка что целевое значение в пределах текущего диапазона 

(double)(r-l)/(arr[r]-arr[l]) - приведение к double для точного деления 

Временная сложность: O(log log n) в среднем случае, O(n) в худшем случае. 
11.Фибоначчи поиск —это эффективный алоритм поиска, используемый для нахождения целевого значения в отсортированной коллекции, такой как массив или список. По принципу он аналогичен бинарному поиску, но использует числа Фибоначчи для определения позиций для сравнения Python 
Объяснение работы алгоритма: 

Алгоритм использует числа Фибоначчи для определения позиций сравнения 

Работает только с отсортированными массивами 

Использует три последовательных числа Фибоначчи для определения области поиска 

На каждом шаге сужает область поиска используя свойства чисел Фибоначчи 

min(offset+fib2, n-1) - ограничение индекса пределами массива 

elif - сокращение от else if, проверка дополнительного условия 



Временная сложность: O(log n) во всех случаях. 
